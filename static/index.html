<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Interact with transformer2</title>
<style>
body {
    font-family: sans-serif;
}
div.tokenholder.p0 {
    padding: 0.5em;
    display: inline-block;
    background: #afc;
}
div.tokenholder.p1 {
    padding: 0.5em;
    display: inline-block;
    background: #fac;
}
div.canvasholder {
    background: #ccf;
    display: inline-block;
}
textarea {
    width: 100%;
    box-sizing: border-box;
    padding: 0.5em;
    margin: 0.5em 0.5em;
}
span.token {
    padding: 0.2em;
    margin: 0.5em 0.2em;
    border: 1px solid #668;
    border-radius: 0.2em;
    background-color: #ccf;
    white-space: pre;
}
span.token.h {
    background-color: #88f;
}
button {
    padding: 0.5em;
    margin: 0.5em 0.5em;
}
button.x {
    color: red;
}
</style>
<script>
"use strict";

let running = false;
let queued = false;

class TokenGadget {
    constructor(n) {
        this.n = n;
    }

    async run(prompt0, prompt1, model0, model1, t0, t1) {
        const p = [prompt0, prompt1][this.n];
        const m = [model0, model1][this.n];
        const response = await fetch("/api/tokenize", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({prompt: p, model: m}),
        });
        if (!response.ok) {
            throw new Error(`Failed to tokenize: ${response.statusText}`);
        }
        const {tokens} = await response.json();
        const tokensDiv = document.createElement('div');
        tokensDiv.className = `tokenholder p${this.n}`;
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const tokenDiv = document.createElement("span");
            if (i === t0 || i === t1) {
                tokenDiv.className = "token h";
            } else {
                tokenDiv.className = "token";
            }
            tokenDiv.textContent = token.name;
            tokensDiv.appendChild(tokenDiv);
        }
        return tokensDiv;
    }
}

class AttnGadget {
    constructor(diff) {
        this.diff = diff;
    }

    async run(prompt0, prompt1, model0, model1, t0, t1) {
        const response = await fetch("/api/attention", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({prompt: prompt0, model: model0}),
        });
        if (!response.ok) {
            throw new Error(`Failed to get attention: ${response.statusText}`);
        }

        const n_layer = parseInt(response.headers.get("X-layers"));
        const n_head = parseInt(response.headers.get("X-heads"));
        const n_token = parseInt(response.headers.get("X-tokens"));
        const bytes = await response.arrayBuffer();
        const view = new DataView(bytes);

        let view2 = undefined;
        let max_token = n_token;
        let n_token2 = undefined;
        if (this.diff) {
            const response2 = await fetch("/api/attention", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({prompt: prompt1, model: model1}),
            });
            if (!response2.ok) {
                throw new Error(`Failed to get attention: ${response2.statusText}`);
            }
            n_token2 = parseInt(response2.headers.get("X-tokens"));
            const bytes2 = await response2.arrayBuffer();
            view2 = new DataView(bytes2);
            max_token = Math.max(n_token, n_token2);
        }

        const canvas = document.createElement('canvas');
        canvas.width = 10 * (max_token + 1) * n_head;
        canvas.height = 10 * (max_token + 1) * n_layer;
        const ctx = canvas.getContext('2d');
        for (let layer = 0; layer < n_layer; layer++) {
            for (let head = 0; head < n_head; head++) {
                for (let t0 = 0; t0 < max_token; t0++) {
                    for (let t1 = 0; t1 < max_token; t1++) {
                        let r = 0;
                        let g = 0;
                        let b = 0;
                        let value = 0;
                        if (t0 < n_token && t1 < n_token) {
                            value = view.getFloat32(4 * (t1 + n_token * (t0 + n_token * (head + n_head * layer))), true);
                            g = Math.pow(value, 0.8)*255;
                        }
                        if (this.diff && t0 < n_token2 && t1 < n_token2) {
                            const value2 = view2.getFloat32(4 * (t1 + n_token2 * (t0 + n_token2 * (head + n_head * layer))), true);
                            r = Math.pow(value2, 0.8)*255;
                            b = Math.pow((value + value2) / 2, 0.8) * 255;
                        }
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(10 * (head * (max_token + 1) + t1), 10 * (layer * (max_token + 1) + t0), 10, 10);
                    }
                }
            }
        }
        canvas.onmousedown = function() {
            const size = 10 * (max_token + 1);
            const t0 = Math.floor((event.offsetY % size) / 10);
            const t1 = Math.floor((event.offsetX % size) / 10);
            if (t0 >= max_token || t1 >= max_token) {
                highlight_token_pair(undefined, undefined);
            } else {
                highlight_token_pair(t0, t1);
            }
        };
        const div = document.createElement('div');
        div.className = "canvasholder";
        div.appendChild(canvas);
        return div;
    }

}

class GadgetHolder {
    constructor() {
        this.gadgets = [new TokenGadget(0), new TokenGadget(1), new AttnGadget(true)];
    }

    async run(t0, t1) {
        if (running) {
            queued = true;
            return;
        }
        running = true;
        const prompt0 = document.getElementById("prompt0").value;
        const prompt1 = document.getElementById("prompt1").value;
        const model0 = document.getElementById("model0").value;
        const model1 = document.getElementById("model1").value;
        const div = document.createElement('div');
        for (const gadget of this.gadgets) {
            const thing = this;
            const gdiv = await gadget.run(prompt0, prompt1, model0, model1, t0, t1);
            const xdiv = document.createElement('div');
            const xbutton = document.createElement('button');
            xbutton.className = 'x';
            xbutton.textContent = "X";
            xbutton.onclick = function() {console.log('foo'); thing.remove(gadget); return true};
            xdiv.appendChild(xbutton);
            xdiv.appendChild(gdiv);
            div.appendChild(xdiv);
        }
        const holderDiv = document.getElementById("gadgets");
        holderDiv.innerHTML = "";
        holderDiv.appendChild(div);
        running = false;
        if (queued) {
            queued = false;
            await this.run(t0, t1);
        }
    }

    async add(gadget) {
        this.gadgets.push(gadget);
        await this.run();
    }

    async remove(gadget) {
        this.gadgets = this.gadgets.filter(g => g !== gadget);
        await this.run();
    }
}

const gadgetHolder = new GadgetHolder();

async function handle_prompt() {
    await gadgetHolder.run(undefined, undefined);
}

async function highlight_token_pair(t0, t1) {
    await gadgetHolder.run(t0, t1);
}

async function load() {
    const response = await fetch("/api/models");
    if (!response.ok) {
        alert(`Failed to get models: ${response.statusText}`);
    }
    const {models} = await response.json();
    const sel0 = document.getElementById("model0");
    const sel1 = document.getElementById("model1");
    sel0.innerHTML = "";
    sel1.innerHTML = "";
    for (const model of models) {
        const option0 = document.createElement('option');
        option0.value = model;
        option0.textContent = model;
        sel0.appendChild(option0);
        const option1 = document.createElement('option');
        option1.value = model;
        option1.textContent = model;
        sel1.appendChild(option1);
    }
    await handle_prompt();
}

window.onload = load;

</script>
</head>
<body>
<div>
<select id="model0" onchange="handle_prompt()" autocomplete="off">
</select>
<br>
<textarea id="prompt0" value="" onkeyup="handle_prompt()" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
</textarea>
<br>
<select id="model1" onchange="handle_prompt()" autocomplete="off">
</select>
<br>
<textarea id="prompt1" value="" onkeyup="handle_prompt()" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
</textarea>
<br>
</div>
<div>
<button onclick="gadgetHolder.add(new TokenGadget(0))">Tokenizer 0</button>
<button onclick="gadgetHolder.add(new TokenGadget(1))">Tokenizer 1</button>
<button onclick="gadgetHolder.add(new AttnGadget(False))">Attention</button>
<button onclick="gadgetHolder.add(new AttnGadget(True))">Diff</button>
</div>
<div id="gadgets"></div>
</body>
</html>